{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./extensions/IERC20Metadata.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by\n            // decrementing then incrementing.\n            _balances[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        unchecked {\n            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\n            _balances[account] += amount;\n        }\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n            // Overflow not possible: amount <= accountBalance <= totalSupply.\n            _totalSupply -= amount;\n        }\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1);\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator,\n        Rounding rounding\n    ) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10**64) {\n                value /= 10**64;\n                result += 64;\n            }\n            if (value >= 10**32) {\n                value /= 10**32;\n                result += 32;\n            }\n            if (value >= 10**16) {\n                value /= 10**16;\n                result += 16;\n            }\n            if (value >= 10**8) {\n                value /= 10**8;\n                result += 8;\n            }\n            if (value >= 10**4) {\n                value /= 10**4;\n                result += 4;\n            }\n            if (value >= 10**2) {\n                value /= 10**2;\n                result += 2;\n            }\n            if (value >= 10**1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10**result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result * 8) < value ? 1 : 0);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/structs/EnumerableSet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/structs/EnumerableSet.sol)\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n *\n * [WARNING]\n * ====\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\n * unusable.\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\n *\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\n * array of EnumerableSet.\n * ====\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping(bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (lastIndex != toDeleteIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the last value to the index where the value to delete is\n                set._values[toDeleteIndex] = lastValue;\n                // Update the index for the moved value\n                set._indexes[lastValue] = valueIndex; // Replace lastValue's index to valueIndex\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        bytes32[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n"
    },
    "contracts/Configuration.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.28;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nstruct MarketplaceConfig {\n  CollateralConfig collateral;\n  ProofConfig proofs;\n  SlotReservationsConfig reservations;\n  uint64 requestDurationLimit;\n}\n\nstruct CollateralConfig {\n  /// @dev percentage of collateral that is used as repair reward\n  uint8 repairRewardPercentage;\n  uint8 maxNumberOfSlashes; // frees slot when the number of slashing reaches this value\n  uint8 slashPercentage; // percentage of the collateral that is slashed\n  uint8 validatorRewardPercentage; // percentage of the slashed amount going to the validators\n}\n\nstruct ProofConfig {\n  uint64 period; // proofs requirements are calculated per period (in seconds)\n  uint64 timeout; // mark proofs as missing before the timeout (in seconds)\n  uint8 downtime; // ignore this much recent blocks for proof requirements\n  // Ensures the pointer does not remain in downtime for many consecutive\n  // periods. For each period increase, move the pointer `pointerProduct`\n  // blocks. Should be a prime number to ensure there are no cycles.\n  uint8 downtimeProduct;\n  string zkeyHash; // hash of the zkey file which is linked to the verifier\n}\n\nstruct SlotReservationsConfig {\n  // Number of allowed reservations per slot\n  uint8 maxReservations;\n}\n"
    },
    "contracts/Endian.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.28;\n\ncontract Endian {\n  /// reverses byte order to allow conversion between little endian and big\n  /// endian integers\n  function _byteSwap(bytes32 input) internal pure returns (bytes32 output) {\n    output = output | bytes1(input);\n    for (uint i = 1; i < 32; i++) {\n      output = output >> 8;\n      output = output | bytes1(input << (i * 8));\n    }\n  }\n}\n"
    },
    "contracts/FuzzMarketplace.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.28;\n\nimport \"./TestToken.sol\";\nimport \"./Marketplace.sol\";\nimport \"./TestVerifier.sol\";\n\ncontract FuzzMarketplace is Marketplace {\n  constructor()\n    Marketplace(\n      MarketplaceConfig(\n        CollateralConfig(10, 5, 10, 20),\n        ProofConfig(10, 5, 64, 67, \"\"),\n        SlotReservationsConfig(20),\n        60 * 60 * 24 * 30 // 30 days\n      ),\n      new TestToken(),\n      new TestVerifier()\n    )\n  // solhint-disable-next-line no-empty-blocks\n  {\n\n  }\n\n  // Properties to be tested through fuzzing\n\n  MarketplaceTotals private _lastSeenTotals;\n\n  function neverDecreaseTotals() public {\n    assert(_marketplaceTotals.received >= _lastSeenTotals.received);\n    assert(_marketplaceTotals.sent >= _lastSeenTotals.sent);\n    _lastSeenTotals = _marketplaceTotals;\n  }\n\n  function neverLoseFunds() public view {\n    uint256 total = _marketplaceTotals.received - _marketplaceTotals.sent;\n    assert(token().balanceOf(address(this)) >= total);\n  }\n}\n"
    },
    "contracts/Groth16.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.28;\n\nstruct G1Point {\n  uint256 x;\n  uint256 y;\n}\n\n// A field element F_{p^2} encoded as `real + i * imag`.\n// We chose to not represent this as an array of 2 numbers, because both Circom\n// and Ethereum EIP-197 encode to an array, but with conflicting encodings.\nstruct Fp2Element {\n  uint256 real;\n  uint256 imag;\n}\n\nstruct G2Point {\n  Fp2Element x;\n  Fp2Element y;\n}\n\nstruct Groth16Proof {\n  G1Point a;\n  G2Point b;\n  G1Point c;\n}\n\ninterface IGroth16Verifier {\n  function verify(\n    Groth16Proof calldata proof,\n    uint256[] calldata pubSignals\n  ) external view returns (bool);\n}\n"
    },
    "contracts/Groth16Verifier.sol": {
      "content": "// Copyright 2017 Christian Reitwiessner\n// Copyright 2019 OKIMS\n// Copyright 2024 Codex\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.28;\nimport \"./Groth16.sol\";\n\ncontract Groth16Verifier is IGroth16Verifier {\n  uint256 private constant _P =\n    21888242871839275222246405745257275088696311157297823662689037894645226208583;\n  uint256 private constant _R =\n    21888242871839275222246405745257275088548364400416034343698204186575808495617;\n\n  VerifyingKey private _verifyingKey;\n\n  struct VerifyingKey {\n    G1Point alpha1;\n    G2Point beta2;\n    G2Point gamma2;\n    G2Point delta2;\n    G1Point[] ic;\n  }\n\n  constructor(VerifyingKey memory key) {\n    _verifyingKey.alpha1 = key.alpha1;\n    _verifyingKey.beta2 = key.beta2;\n    _verifyingKey.gamma2 = key.gamma2;\n    _verifyingKey.delta2 = key.delta2;\n    for (uint i = 0; i < key.ic.length; i++) {\n      _verifyingKey.ic.push(key.ic[i]);\n    }\n  }\n\n  function _negate(G1Point memory point) private pure returns (G1Point memory) {\n    return G1Point(point.x, (_P - point.y) % _P);\n  }\n\n  function _add(\n    G1Point memory point1,\n    G1Point memory point2\n  ) private view returns (bool success, G1Point memory sum) {\n    // Call the precompiled contract for addition on the alt_bn128 curve.\n    // The call will fail if the points are not valid group elements:\n    // https://eips.ethereum.org/EIPS/eip-196#exact-semantics\n\n    uint256[4] memory input;\n    input[0] = point1.x;\n    input[1] = point1.y;\n    input[2] = point2.x;\n    input[3] = point2.y;\n    // solhint-disable-next-line no-inline-assembly\n    assembly {\n      success := staticcall(gas(), 6, input, 128, sum, 64)\n    }\n  }\n\n  function _multiply(\n    G1Point memory point,\n    uint256 scalar\n  ) private view returns (bool success, G1Point memory product) {\n    // Call the precompiled contract for scalar multiplication on the alt_bn128\n    // curve. The call will fail if the points are not valid group elements:\n    // https://eips.ethereum.org/EIPS/eip-196#exact-semantics\n\n    uint256[3] memory input;\n    input[0] = point.x;\n    input[1] = point.y;\n    input[2] = scalar;\n    // solhint-disable-next-line no-inline-assembly\n    assembly {\n      success := staticcall(gas(), 7, input, 96, product, 64)\n    }\n  }\n\n  function _checkPairing(\n    G1Point memory a1,\n    G2Point memory a2,\n    G1Point memory b1,\n    G2Point memory b2,\n    G1Point memory c1,\n    G2Point memory c2,\n    G1Point memory d1,\n    G2Point memory d2\n  ) private view returns (bool success, uint256 outcome) {\n    // Call the precompiled contract for pairing check on the alt_bn128 curve.\n    // The call will fail if the points are not valid group elements:\n    // https://eips.ethereum.org/EIPS/eip-197#specification\n\n    uint256[24] memory input; // 4 pairs of G1 and G2 points\n    uint256[1] memory output;\n\n    input[0] = a1.x;\n    input[1] = a1.y;\n    input[2] = a2.x.imag;\n    input[3] = a2.x.real;\n    input[4] = a2.y.imag;\n    input[5] = a2.y.real;\n\n    input[6] = b1.x;\n    input[7] = b1.y;\n    input[8] = b2.x.imag;\n    input[9] = b2.x.real;\n    input[10] = b2.y.imag;\n    input[11] = b2.y.real;\n\n    input[12] = c1.x;\n    input[13] = c1.y;\n    input[14] = c2.x.imag;\n    input[15] = c2.x.real;\n    input[16] = c2.y.imag;\n    input[17] = c2.y.real;\n\n    input[18] = d1.x;\n    input[19] = d1.y;\n    input[20] = d2.x.imag;\n    input[21] = d2.x.real;\n    input[22] = d2.y.imag;\n    input[23] = d2.y.real;\n\n    // solhint-disable-next-line no-inline-assembly\n    assembly {\n      success := staticcall(gas(), 8, input, 768, output, 32)\n    }\n    return (success, output[0]);\n  }\n\n  function verify(\n    Groth16Proof calldata proof,\n    uint256[] memory input\n  ) public view returns (bool success) {\n    // Check amount of public inputs\n    if (input.length + 1 != _verifyingKey.ic.length) {\n      return false;\n    }\n    // Check that public inputs are field elements\n    for (uint i = 0; i < input.length; i++) {\n      if (input[i] >= _R) {\n        return false;\n      }\n    }\n    // Compute the linear combination\n    G1Point memory combination = _verifyingKey.ic[0];\n    for (uint i = 0; i < input.length; i++) {\n      G1Point memory product;\n      (success, product) = _multiply(_verifyingKey.ic[i + 1], input[i]);\n      if (!success) {\n        return false;\n      }\n      (success, combination) = _add(combination, product);\n      if (!success) {\n        return false;\n      }\n    }\n    // Check the pairing\n    uint256 outcome;\n    (success, outcome) = _checkPairing(\n      _negate(proof.a),\n      proof.b,\n      _verifyingKey.alpha1,\n      _verifyingKey.beta2,\n      combination,\n      _verifyingKey.gamma2,\n      proof.c,\n      _verifyingKey.delta2\n    );\n    if (!success) {\n      return false;\n    }\n    return outcome == 1;\n  }\n}\n"
    },
    "contracts/Marketplace.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.28;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\nimport \"./Configuration.sol\";\nimport \"./Requests.sol\";\nimport \"./Proofs.sol\";\nimport \"./SlotReservations.sol\";\nimport \"./StateRetrieval.sol\";\nimport \"./Endian.sol\";\nimport \"./Groth16.sol\";\n\ncontract Marketplace is SlotReservations, Proofs, StateRetrieval, Endian {\n  error Marketplace_RepairRewardPercentageTooHigh();\n  error Marketplace_SlashPercentageTooHigh();\n  error Marketplace_MaximumSlashingTooHigh();\n  error Marketplace_InvalidExpiry();\n  error Marketplace_InvalidMaxSlotLoss();\n  error Marketplace_InsufficientSlots();\n  error Marketplace_InsufficientDuration();\n  error Marketplace_InsufficientProofProbability();\n  error Marketplace_InsufficientCollateral();\n  error Marketplace_InsufficientReward();\n  error Marketplace_InvalidClientAddress();\n  error Marketplace_RequestAlreadyExists();\n  error Marketplace_InvalidSlot();\n  error Marketplace_InvalidCid();\n  error Marketplace_SlotNotFree();\n  error Marketplace_InvalidSlotHost();\n  error Marketplace_AlreadyPaid();\n  error Marketplace_TransferFailed();\n  error Marketplace_UnknownRequest();\n  error Marketplace_InvalidState();\n  error Marketplace_StartNotBeforeExpiry();\n  error Marketplace_SlotNotAcceptingProofs();\n  error Marketplace_SlotIsFree();\n  error Marketplace_ReservationRequired();\n  error Marketplace_NothingToWithdraw();\n  error Marketplace_DurationExceedsLimit();\n\n  using EnumerableSet for EnumerableSet.Bytes32Set;\n  using EnumerableSet for EnumerableSet.AddressSet;\n  using Requests for Request;\n  using AskHelpers for Ask;\n\n  IERC20 private immutable _token;\n  MarketplaceConfig private _config;\n\n  mapping(RequestId => Request) private _requests;\n  mapping(RequestId => RequestContext) internal _requestContexts;\n  mapping(SlotId => Slot) internal _slots;\n\n  MarketplaceTotals internal _marketplaceTotals;\n\n  struct RequestContext {\n    RequestState state;\n    /// @notice Tracks how much funds should be returned to the client as not all funds might be used for hosting the request\n    /// @dev The sum starts with the full reward amount for the request and is reduced every time a host fills a slot.\n    ///      The reduction is calculated from the duration of time between the slot being filled and the request's end.\n    ///      This is the amount that will be paid out to the host when the request successfully finishes.\n    /// @dev fundsToReturnToClient == 0 is used to signal that after request is terminated all the remaining funds were withdrawn.\n    ///      This is possible, because technically it is not possible for this variable to reach 0 in \"natural\" way as\n    ///      that would require all the slots to be filled at the same block as the request was created.\n    uint256 fundsToReturnToClient;\n    uint64 slotsFilled;\n    uint64 startedAt;\n    uint64 endsAt;\n    uint64 expiresAt;\n  }\n\n  struct Slot {\n    SlotState state;\n    RequestId requestId;\n    /// @notice Timestamp that signals when slot was filled\n    /// @dev Used for calculating payouts as hosts are paid\n    ///      based on time they actually host the content\n    uint64 filledAt;\n    uint64 slotIndex;\n    /// @notice Tracks the current amount of host's collateral that is\n    ///         to be payed out at the end of Slot's lifespan.\n    /// @dev    When Slot is filled, the collateral is collected in amount\n    ///         of request.ask.collateralPerByte * request.ask.slotSize\n    ///         (== request.ask.collateralPerSlot() when using the AskHelpers library)\n    /// @dev    When Host is slashed for missing a proof the slashed amount is\n    ///         reflected in this variable\n    uint256 currentCollateral;\n    /// @notice address used for collateral interactions and identifying hosts\n    address host;\n  }\n\n  struct ActiveSlot {\n    Request request;\n    uint64 slotIndex;\n  }\n\n  constructor(\n    MarketplaceConfig memory config,\n    IERC20 token_,\n    IGroth16Verifier verifier\n  ) SlotReservations(config.reservations) Proofs(config.proofs, verifier) {\n    _token = token_;\n\n    if (config.collateral.repairRewardPercentage > 100)\n      revert Marketplace_RepairRewardPercentageTooHigh();\n    if (config.collateral.slashPercentage > 100)\n      revert Marketplace_SlashPercentageTooHigh();\n\n    if (\n      config.collateral.maxNumberOfSlashes * config.collateral.slashPercentage >\n      100\n    ) {\n      revert Marketplace_MaximumSlashingTooHigh();\n    }\n    _config = config;\n  }\n\n  function configuration() public view returns (MarketplaceConfig memory) {\n    return _config;\n  }\n\n  function token() public view returns (IERC20) {\n    return _token;\n  }\n\n  function currentCollateral(SlotId slotId) public view returns (uint256) {\n    return _slots[slotId].currentCollateral;\n  }\n\n  function requestStorage(Request calldata request) public {\n    RequestId id = request.id();\n\n    if (request.client != msg.sender) revert Marketplace_InvalidClientAddress();\n    if (_requests[id].client != address(0)) {\n      revert Marketplace_RequestAlreadyExists();\n    }\n    if (request.expiry == 0 || request.expiry >= request.ask.duration)\n      revert Marketplace_InvalidExpiry();\n    if (request.ask.slots == 0) revert Marketplace_InsufficientSlots();\n    if (request.ask.maxSlotLoss > request.ask.slots)\n      revert Marketplace_InvalidMaxSlotLoss();\n    if (request.ask.duration == 0) {\n      revert Marketplace_InsufficientDuration();\n    }\n    if (request.ask.proofProbability == 0) {\n      revert Marketplace_InsufficientProofProbability();\n    }\n    if (request.ask.collateralPerByte == 0) {\n      revert Marketplace_InsufficientCollateral();\n    }\n    if (request.ask.pricePerBytePerSecond == 0) {\n      revert Marketplace_InsufficientReward();\n    }\n    if (bytes(request.content.cid).length == 0) {\n      revert Marketplace_InvalidCid();\n    }\n    if (request.ask.duration > _config.requestDurationLimit) {\n      revert Marketplace_DurationExceedsLimit();\n    }\n\n    _requests[id] = request;\n    _requestContexts[id].endsAt =\n      uint64(block.timestamp) +\n      request.ask.duration;\n    _requestContexts[id].expiresAt = uint64(block.timestamp) + request.expiry;\n\n    _addToMyRequests(request.client, id);\n\n    uint256 amount = request.maxPrice();\n    _requestContexts[id].fundsToReturnToClient = amount;\n    _marketplaceTotals.received += amount;\n    _transferFrom(msg.sender, amount);\n\n    emit StorageRequested(id, request.ask, _requestContexts[id].expiresAt);\n  }\n\n  /**\n   * @notice Fills a slot. Reverts if an invalid proof of the slot data is\n     provided.\n   * @param requestId RequestId identifying the request containing the slot to\n     fill.\n   * @param slotIndex Index of the slot in the request.\n   * @param proof Groth16 proof procing possession of the slot data.\n   */\n  function fillSlot(\n    RequestId requestId,\n    uint64 slotIndex,\n    Groth16Proof calldata proof\n  ) public requestIsKnown(requestId) {\n    Request storage request = _requests[requestId];\n    if (slotIndex >= request.ask.slots) revert Marketplace_InvalidSlot();\n\n    SlotId slotId = Requests.slotId(requestId, slotIndex);\n\n    if (!_reservations[slotId].contains(msg.sender))\n      revert Marketplace_ReservationRequired();\n\n    Slot storage slot = _slots[slotId];\n    slot.requestId = requestId;\n    slot.slotIndex = slotIndex;\n    RequestContext storage context = _requestContexts[requestId];\n\n    if (\n      slotState(slotId) != SlotState.Free &&\n      slotState(slotId) != SlotState.Repair\n    ) {\n      revert Marketplace_SlotNotFree();\n    }\n\n    _startRequiringProofs(slotId);\n    submitProof(slotId, proof);\n\n    slot.host = msg.sender;\n    slot.filledAt = uint64(block.timestamp);\n\n    context.slotsFilled += 1;\n    context.fundsToReturnToClient -= _slotPayout(requestId, slot.filledAt);\n\n    // Collect collateral\n    uint256 collateralAmount;\n    uint256 collateralPerSlot = request.ask.collateralPerSlot();\n    if (slotState(slotId) == SlotState.Repair) {\n      // Host is repairing a slot and is entitled for repair reward, so he gets \"discounted collateral\"\n      // in this way he gets \"physically\" the reward at the end of the request when the full amount of collateral\n      // is returned to him.\n      collateralAmount =\n        collateralPerSlot -\n        ((collateralPerSlot * _config.collateral.repairRewardPercentage) / 100);\n    } else {\n      collateralAmount = collateralPerSlot;\n    }\n    _transferFrom(msg.sender, collateralAmount);\n    _marketplaceTotals.received += collateralAmount;\n    slot.currentCollateral = collateralPerSlot; // Even if he has collateral discounted, he is operating with full collateral\n\n    _addToMySlots(slot.host, slotId);\n\n    slot.state = SlotState.Filled;\n    emit SlotFilled(requestId, slotIndex);\n\n    if (\n      context.slotsFilled == request.ask.slots &&\n      context.state == RequestState.New // Only New requests can \"start\" the requests\n    ) {\n      context.state = RequestState.Started;\n      context.startedAt = uint64(block.timestamp);\n      emit RequestFulfilled(requestId);\n    }\n  }\n\n  /**\n     * @notice Frees a slot, paying out rewards and returning collateral for\n     finished or cancelled requests to the host that has filled the slot.\n   * @param slotId id of the slot to free\n   * @dev The host that filled the slot must have initiated the transaction\n     (msg.sender). This overload allows `rewardRecipient` and\n     `collateralRecipient` to be optional.\n   */\n  function freeSlot(SlotId slotId) public slotIsNotFree(slotId) {\n    return freeSlot(slotId, msg.sender, msg.sender);\n  }\n\n  /**\n     * @notice Frees a slot, paying out rewards and returning collateral for\n     finished or cancelled requests.\n   * @param slotId id of the slot to free\n   * @param rewardRecipient address to send rewards to\n   * @param collateralRecipient address to refund collateral to\n   */\n  function freeSlot(\n    SlotId slotId,\n    address rewardRecipient,\n    address collateralRecipient\n  ) public slotIsNotFree(slotId) {\n    Slot storage slot = _slots[slotId];\n    if (slot.host != msg.sender) revert Marketplace_InvalidSlotHost();\n\n    SlotState state = slotState(slotId);\n    if (state == SlotState.Paid) revert Marketplace_AlreadyPaid();\n\n    if (state == SlotState.Finished) {\n      _payoutSlot(slot.requestId, slotId, rewardRecipient, collateralRecipient);\n    } else if (state == SlotState.Cancelled) {\n      _payoutCancelledSlot(\n        slot.requestId,\n        slotId,\n        rewardRecipient,\n        collateralRecipient\n      );\n    } else if (state == SlotState.Failed) {\n      _removeFromMySlots(msg.sender, slotId);\n    } else if (state == SlotState.Filled) {\n      // free slot without returning collateral, effectively a 100% slash\n      _forciblyFreeSlot(slotId);\n    }\n  }\n\n  function _challengeToFieldElement(\n    bytes32 challenge\n  ) internal pure returns (uint256) {\n    // use only 31 bytes of the challenge to ensure that it fits into the field\n    bytes32 truncated = bytes32(bytes31(challenge));\n    // convert from little endian to big endian\n    bytes32 bigEndian = _byteSwap(truncated);\n    // convert bytes to integer\n    return uint256(bigEndian);\n  }\n\n  function _merkleRootToFieldElement(\n    bytes32 merkleRoot\n  ) internal pure returns (uint256) {\n    // convert from little endian to big endian\n    bytes32 bigEndian = _byteSwap(merkleRoot);\n    // convert bytes to integer\n    return uint256(bigEndian);\n  }\n\n  function submitProof(\n    SlotId id,\n    Groth16Proof calldata proof\n  ) public requestIsKnown(_slots[id].requestId) {\n    Slot storage slot = _slots[id];\n    Request storage request = _requests[slot.requestId];\n    uint256[] memory pubSignals = new uint256[](3);\n    pubSignals[0] = _challengeToFieldElement(getChallenge(id));\n    pubSignals[1] = _merkleRootToFieldElement(request.content.merkleRoot);\n    pubSignals[2] = slot.slotIndex;\n    _proofReceived(id, proof, pubSignals);\n  }\n\n  function markProofAsMissing(SlotId slotId, Period period) public {\n    if (slotState(slotId) != SlotState.Filled)\n      revert Marketplace_SlotNotAcceptingProofs();\n\n    _markProofAsMissing(slotId, period);\n    Slot storage slot = _slots[slotId];\n    Request storage request = _requests[slot.requestId];\n\n    uint256 slashedAmount = (request.ask.collateralPerSlot() *\n      _config.collateral.slashPercentage) / 100;\n\n    uint256 validatorRewardAmount = (slashedAmount *\n      _config.collateral.validatorRewardPercentage) / 100;\n    _marketplaceTotals.sent += validatorRewardAmount;\n    assert(_token.transfer(msg.sender, validatorRewardAmount));\n\n    slot.currentCollateral -= slashedAmount;\n    if (missingProofs(slotId) >= _config.collateral.maxNumberOfSlashes) {\n      // When the number of slashings is at or above the allowed amount,\n      // free the slot.\n      _forciblyFreeSlot(slotId);\n    }\n  }\n\n  /**\n     * @notice Abandons the slot without returning collateral, effectively slashing the\n     entire collateral.\n   * @param slotId SlotId of the slot to free.\n   * @dev _slots[slotId] is deleted, resetting _slots[slotId].currentCollateral\n     to 0.\n  */\n  function _forciblyFreeSlot(SlotId slotId) internal {\n    Slot storage slot = _slots[slotId];\n    RequestId requestId = slot.requestId;\n    RequestContext storage context = _requestContexts[requestId];\n\n    // We need to refund the amount of payout of the current node to the `fundsToReturnToClient` so\n    // we keep correctly the track of the funds that needs to be returned at the end.\n    context.fundsToReturnToClient += _slotPayout(requestId, slot.filledAt);\n\n    _removeFromMySlots(slot.host, slotId);\n    delete _reservations[slotId]; // We purge all the reservations for the slot\n    slot.state = SlotState.Repair;\n    slot.filledAt = 0;\n    slot.currentCollateral = 0;\n    slot.host = address(0);\n    context.slotsFilled -= 1;\n    emit SlotFreed(requestId, slot.slotIndex);\n    _resetMissingProofs(slotId);\n\n    Request storage request = _requests[requestId];\n    uint256 slotsLost = request.ask.slots - context.slotsFilled;\n    if (\n      slotsLost > request.ask.maxSlotLoss &&\n      context.state == RequestState.Started\n    ) {\n      context.state = RequestState.Failed;\n      context.endsAt = uint64(block.timestamp) - 1;\n      emit RequestFailed(requestId);\n    }\n  }\n\n  function _payoutSlot(\n    RequestId requestId,\n    SlotId slotId,\n    address rewardRecipient,\n    address collateralRecipient\n  ) private requestIsKnown(requestId) {\n    RequestContext storage context = _requestContexts[requestId];\n    Request storage request = _requests[requestId];\n    context.state = RequestState.Finished;\n    Slot storage slot = _slots[slotId];\n\n    _removeFromMyRequests(request.client, requestId);\n    _removeFromMySlots(slot.host, slotId);\n\n    uint256 payoutAmount = _slotPayout(requestId, slot.filledAt);\n    uint256 collateralAmount = slot.currentCollateral;\n    _marketplaceTotals.sent += (payoutAmount + collateralAmount);\n    slot.state = SlotState.Paid;\n    if (!_token.transfer(rewardRecipient, payoutAmount)) {\n      revert Marketplace_TransferFailed();\n    }\n\n    if (!_token.transfer(collateralRecipient, collateralAmount)) {\n      revert Marketplace_TransferFailed();\n    }\n  }\n\n  /**\n     * @notice Pays out a host for duration of time that the slot was filled, and\n     returns the collateral.\n   * @dev The payouts are sent to the rewardRecipient, and collateral is returned\n     to the host address.\n   * @param requestId RequestId of the request that contains the slot to be paid\n     out.\n   * @param slotId SlotId of the slot to be paid out.\n   */\n  function _payoutCancelledSlot(\n    RequestId requestId,\n    SlotId slotId,\n    address rewardRecipient,\n    address collateralRecipient\n  ) private requestIsKnown(requestId) {\n    Slot storage slot = _slots[slotId];\n    _removeFromMySlots(slot.host, slotId);\n\n    uint256 payoutAmount = _slotPayout(\n      requestId,\n      slot.filledAt,\n      requestExpiry(requestId)\n    );\n    uint256 collateralAmount = slot.currentCollateral;\n    _marketplaceTotals.sent += (payoutAmount + collateralAmount);\n    slot.state = SlotState.Paid;\n    if (!_token.transfer(rewardRecipient, payoutAmount)) {\n      revert Marketplace_TransferFailed();\n    }\n\n    if (!_token.transfer(collateralRecipient, collateralAmount)) {\n      revert Marketplace_TransferFailed();\n    }\n  }\n\n  /**\n     * @notice Withdraws remaining storage request funds back to the client that\n     deposited them.\n   * @dev Request must be cancelled, failed or finished, and the\n     transaction must originate from the depositor address.\n   * @param requestId the id of the request\n   */\n  function withdrawFunds(RequestId requestId) public {\n    withdrawFunds(requestId, msg.sender);\n  }\n\n  /**\n     * @notice Withdraws storage request funds to the provided address.\n   * @dev Request must be expired, must be in RequestState.New, and the\n     transaction must originate from the depositer address.\n   * @param requestId the id of the request\n   * @param withdrawRecipient address to return the remaining funds to\n   */\n  function withdrawFunds(\n    RequestId requestId,\n    address withdrawRecipient\n  ) public requestIsKnown(requestId) {\n    Request storage request = _requests[requestId];\n    RequestContext storage context = _requestContexts[requestId];\n\n    if (request.client != msg.sender) revert Marketplace_InvalidClientAddress();\n\n    RequestState state = requestState(requestId);\n    if (\n      state != RequestState.Cancelled &&\n      state != RequestState.Failed &&\n      state != RequestState.Finished\n    ) {\n      revert Marketplace_InvalidState();\n    }\n\n    // fundsToReturnToClient == 0 is used for \"double-spend\" protection, once the funds are withdrawn\n    // then this variable is set to 0.\n    if (context.fundsToReturnToClient == 0)\n      revert Marketplace_NothingToWithdraw();\n\n    if (state == RequestState.Cancelled) {\n      context.state = RequestState.Cancelled;\n      emit RequestCancelled(requestId);\n\n      // `fundsToReturnToClient` currently tracks funds to be returned for requests that successfully finish.\n      // When requests are cancelled, funds earmarked for payment for the duration\n      // between request expiry and request end (for every slot that was filled), should be returned to the client.\n      // Update `fundsToReturnToClient` to reflect this.\n      context.fundsToReturnToClient +=\n        context.slotsFilled *\n        _slotPayout(requestId, requestExpiry(requestId));\n    } else if (state == RequestState.Failed) {\n      // For Failed requests the client is refunded whole amount.\n      context.fundsToReturnToClient = request.maxPrice();\n    } else {\n      context.state = RequestState.Finished;\n    }\n\n    _removeFromMyRequests(request.client, requestId);\n\n    uint256 amount = context.fundsToReturnToClient;\n    _marketplaceTotals.sent += amount;\n\n    if (!_token.transfer(withdrawRecipient, amount)) {\n      revert Marketplace_TransferFailed();\n    }\n\n    // We zero out the funds tracking in order to prevent double-spends\n    context.fundsToReturnToClient = 0;\n  }\n\n  function getActiveSlot(\n    SlotId slotId\n  ) public view slotIsNotFree(slotId) returns (ActiveSlot memory) {\n    Slot storage slot = _slots[slotId];\n    ActiveSlot memory activeSlot;\n    activeSlot.request = _requests[slot.requestId];\n    activeSlot.slotIndex = slot.slotIndex;\n    return activeSlot;\n  }\n\n  modifier requestIsKnown(RequestId requestId) {\n    if (_requests[requestId].client == address(0))\n      revert Marketplace_UnknownRequest();\n\n    _;\n  }\n\n  function getRequest(\n    RequestId requestId\n  ) public view requestIsKnown(requestId) returns (Request memory) {\n    return _requests[requestId];\n  }\n\n  modifier slotIsNotFree(SlotId slotId) {\n    if (_slots[slotId].state == SlotState.Free) revert Marketplace_SlotIsFree();\n    _;\n  }\n\n  function _slotIsFree(SlotId slotId) internal view override returns (bool) {\n    return _slots[slotId].state == SlotState.Free;\n  }\n\n  function requestEnd(RequestId requestId) public view returns (uint64) {\n    RequestState state = requestState(requestId);\n    if (state == RequestState.New || state == RequestState.Started) {\n      return _requestContexts[requestId].endsAt;\n    }\n    if (state == RequestState.Cancelled) {\n      return _requestContexts[requestId].expiresAt;\n    }\n    return\n      uint64(Math.min(_requestContexts[requestId].endsAt, block.timestamp));\n  }\n\n  function requestExpiry(RequestId requestId) public view returns (uint64) {\n    return _requestContexts[requestId].expiresAt;\n  }\n\n  /**\n   * @notice Calculates the amount that should be paid out to a host that successfully finished the request\n   * @param requestId RequestId of the request used to calculate the payout\n   * amount.\n   * @param startingTimestamp timestamp indicating when a host filled a slot and\n   * started providing proofs.\n   */\n  function _slotPayout(\n    RequestId requestId,\n    uint64 startingTimestamp\n  ) private view returns (uint256) {\n    return\n      _slotPayout(\n        requestId,\n        startingTimestamp,\n        _requestContexts[requestId].endsAt\n      );\n  }\n\n  /// @notice Calculates the amount that should be paid out to a host based on the specified time frame.\n  function _slotPayout(\n    RequestId requestId,\n    uint64 startingTimestamp,\n    uint64 endingTimestamp\n  ) private view returns (uint256) {\n    Request storage request = _requests[requestId];\n    if (startingTimestamp >= endingTimestamp)\n      revert Marketplace_StartNotBeforeExpiry();\n    return\n      (endingTimestamp - startingTimestamp) *\n      request.ask.pricePerSlotPerSecond();\n  }\n\n  function getHost(SlotId slotId) public view returns (address) {\n    return _slots[slotId].host;\n  }\n\n  function requestState(\n    RequestId requestId\n  ) public view requestIsKnown(requestId) returns (RequestState) {\n    RequestContext storage context = _requestContexts[requestId];\n    if (\n      context.state == RequestState.New &&\n      uint64(block.timestamp) > requestExpiry(requestId)\n    ) {\n      return RequestState.Cancelled;\n    } else if (\n      (context.state == RequestState.Started ||\n        context.state == RequestState.New) &&\n      uint64(block.timestamp) > context.endsAt\n    ) {\n      return RequestState.Finished;\n    } else {\n      return context.state;\n    }\n  }\n\n  function slotState(SlotId slotId) public view override returns (SlotState) {\n    Slot storage slot = _slots[slotId];\n    if (RequestId.unwrap(slot.requestId) == 0) {\n      return SlotState.Free;\n    }\n    RequestState reqState = requestState(slot.requestId);\n    if (slot.state == SlotState.Paid) {\n      return SlotState.Paid;\n    }\n    if (reqState == RequestState.Cancelled) {\n      return SlotState.Cancelled;\n    }\n    if (reqState == RequestState.Finished) {\n      return SlotState.Finished;\n    }\n    if (reqState == RequestState.Failed) {\n      return SlotState.Failed;\n    }\n    return slot.state;\n  }\n\n  function slotProbability(\n    SlotId slotId\n  ) public view override returns (uint256) {\n    Slot storage slot = _slots[slotId];\n    Request storage request = _requests[slot.requestId];\n    return\n      (request.ask.proofProbability * (256 - _config.proofs.downtime)) / 256;\n  }\n\n  function _transferFrom(address sender, uint256 amount) internal {\n    address receiver = address(this);\n    if (!_token.transferFrom(sender, receiver, amount))\n      revert Marketplace_TransferFailed();\n  }\n\n  event StorageRequested(RequestId requestId, Ask ask, uint64 expiry);\n  event RequestFulfilled(RequestId indexed requestId);\n  event RequestFailed(RequestId indexed requestId);\n  event SlotFilled(RequestId indexed requestId, uint64 slotIndex);\n  event SlotFreed(RequestId indexed requestId, uint64 slotIndex);\n  event RequestCancelled(RequestId indexed requestId);\n\n  struct MarketplaceTotals {\n    uint256 received;\n    uint256 sent;\n  }\n}\n"
    },
    "contracts/Periods.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.28;\n\ncontract Periods {\n  error Periods_InvalidSecondsPerPeriod();\n\n  type Period is uint64;\n\n  uint64 internal immutable _secondsPerPeriod;\n\n  constructor(uint64 secondsPerPeriod) {\n    if (secondsPerPeriod == 0) {\n      revert Periods_InvalidSecondsPerPeriod();\n    }\n    _secondsPerPeriod = secondsPerPeriod;\n  }\n\n  function _periodOf(uint64 timestamp) internal view returns (Period) {\n    return Period.wrap(timestamp / _secondsPerPeriod);\n  }\n\n  function _blockPeriod() internal view returns (Period) {\n    return _periodOf(uint64(block.timestamp));\n  }\n\n  function _nextPeriod(Period period) internal pure returns (Period) {\n    return Period.wrap(Period.unwrap(period) + 1);\n  }\n\n  function _periodStart(Period period) internal view returns (uint64) {\n    return Period.unwrap(period) * _secondsPerPeriod;\n  }\n\n  function _periodEnd(Period period) internal view returns (uint64) {\n    return _periodStart(_nextPeriod(period));\n  }\n\n  function _isBefore(Period a, Period b) internal pure returns (bool) {\n    return Period.unwrap(a) < Period.unwrap(b);\n  }\n\n  function _isAfter(Period a, Period b) internal pure returns (bool) {\n    return _isBefore(b, a);\n  }\n}\n"
    },
    "contracts/Proofs.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.28;\n\nimport \"./Configuration.sol\";\nimport \"./Requests.sol\";\nimport \"./Periods.sol\";\nimport \"./Groth16.sol\";\n\n/**\n * @title Proofs\n * @notice Abstract contract that handles proofs tracking, validation and reporting functionality\n */\nabstract contract Proofs is Periods {\n  error Proofs_InsufficientBlockHeight();\n  error Proofs_InvalidProof();\n  error Proofs_ProofAlreadySubmitted();\n  error Proofs_PeriodNotEnded();\n  error Proofs_ValidationTimedOut();\n  error Proofs_ProofNotMissing();\n  error Proofs_ProofNotRequired();\n  error Proofs_ProofAlreadyMarkedMissing();\n\n  ProofConfig private _config;\n  IGroth16Verifier private _verifier;\n\n  /**\n   * Creation of the contract requires at least 256 mined blocks!\n   * @param config Proving configuration\n   */\n  constructor(\n    ProofConfig memory config,\n    IGroth16Verifier verifier\n  ) Periods(config.period) {\n    if (block.number <= 256) {\n      revert Proofs_InsufficientBlockHeight();\n    }\n\n    _config = config;\n    _verifier = verifier;\n  }\n\n  mapping(SlotId => uint64) private _slotStarts;\n  mapping(SlotId => uint64) private _missed;\n  mapping(SlotId => mapping(Period => bool)) private _received;\n  mapping(SlotId => mapping(Period => bool)) private _missing;\n\n  function slotState(SlotId id) public view virtual returns (SlotState);\n\n  /**\n   * @param id  Slot's ID\n   * @return Integer which specifies the probability of how often the proofs will be required. Lower number means higher probability.\n   */\n  function slotProbability(SlotId id) public view virtual returns (uint256);\n\n  /**\n   * @return Number of missed proofs since Slot was Filled\n   */\n  function missingProofs(SlotId slotId) public view returns (uint64) {\n    return _missed[slotId];\n  }\n\n  /**\n   * @param slotId Slot's ID for which the proofs should be reset\n   * @notice Resets the missing proofs counter to zero\n   */\n  function _resetMissingProofs(SlotId slotId) internal {\n    _missed[slotId] = 0;\n  }\n\n  /**\n   * @param id Slot's ID for which the proofs should be started to require\n   * @notice Notes down the block's timestamp as Slot's starting time for requiring proofs\n   *     and saves the required probability.\n   */\n  function _startRequiringProofs(SlotId id) internal {\n    _slotStarts[id] = uint64(block.timestamp);\n  }\n\n  /**\n   * @param id Slot's ID for which the pointer should be calculated\n   * @param period Period for which the pointer should be calculated\n   * @return Uint8 pointer that is stable over current Period, ie an integer offset [0-255] of the last 256 blocks, pointing to a block that remains constant for the entire Period's duration.\n   * @dev For more information see [timing of storage proofs](https://github.com/codex-storage/codex-research/blob/41c4b4409d2092d0a5475aca0f28995034e58d14/design/storage-proof-timing.md)\n   */\n  function _getPointer(SlotId id, Period period) internal view returns (uint8) {\n    uint256 blockNumber = block.number % 256;\n    uint256 periodNumber = (Period.unwrap(period) * _config.downtimeProduct) %\n      256;\n    uint256 idOffset = uint256(SlotId.unwrap(id)) % 256;\n    uint256 pointer = (blockNumber + periodNumber + idOffset) % 256;\n    return uint8(pointer);\n  }\n\n  /**\n   * @param id Slot's ID for which the pointer should be calculated\n   * @return Uint8 pointer that is stable over current Period, ie an integer offset [0-255] of the last 256 blocks, pointing to a block that remains constant for the entire Period's duration.\n   * @dev For more information see [timing of storage proofs](https://github.com/codex-storage/codex-research/blob/41c4b4409d2092d0a5475aca0f28995034e58d14/design/storage-proof-timing.md)\n   */\n  function getPointer(SlotId id) public view returns (uint8) {\n    return _getPointer(id, _blockPeriod());\n  }\n\n  /**\n   * @param pointer Integer [0-255] that indicates an offset of the last 256 blocks, pointing to a block that remains constant for the entire Period's duration.\n   * @return Challenge that should be used for generation of proofs\n   */\n  function _getChallenge(uint8 pointer) internal view returns (bytes32) {\n    bytes32 hash = blockhash(block.number - 1 - pointer);\n    assert(uint256(hash) != 0);\n    return keccak256(abi.encode(hash));\n  }\n\n  /**\n   * @param id Slot's ID for which the challenge should be calculated\n   * @param period Period for which the challenge should be calculated\n   * @return Challenge that should be used for generation of proofs\n   */\n  function _getChallenge(\n    SlotId id,\n    Period period\n  ) internal view returns (bytes32) {\n    return _getChallenge(_getPointer(id, period));\n  }\n\n  /**\n   * @param id Slot's ID for which the challenge should be calculated\n   * @return Challenge for current Period that should be used for generation of proofs\n   */\n  function getChallenge(SlotId id) public view returns (bytes32) {\n    return _getChallenge(id, _blockPeriod());\n  }\n\n  /**\n   * @param id Slot's ID for which the requirements are gathered. If the Slot's state is other than Filled, `false` is always returned.\n   * @param period Period for which the requirements are gathered.\n   */\n  function _getProofRequirement(\n    SlotId id,\n    Period period\n  ) internal view returns (bool isRequired, uint8 pointer) {\n    SlotState state = slotState(id);\n    Period start = _periodOf(_slotStarts[id]);\n    if (state != SlotState.Filled || !_isAfter(period, start)) {\n      return (false, 0);\n    }\n    pointer = _getPointer(id, period);\n    bytes32 challenge = _getChallenge(pointer);\n\n    /// Scaling of the probability according the downtime configuration\n    /// See: https://github.com/codex-storage/codex-research/blob/41c4b4409d2092d0a5475aca0f28995034e58d14/design/storage-proof-timing.md#pointer-downtime\n    uint256 probability = slotProbability(id);\n    isRequired = probability == 0 || uint256(challenge) % probability == 0;\n  }\n\n  /**\n   * See isProofRequired\n   */\n  function _isProofRequired(\n    SlotId id,\n    Period period\n  ) internal view returns (bool) {\n    bool isRequired;\n    uint8 pointer;\n    (isRequired, pointer) = _getProofRequirement(id, period);\n    return isRequired && pointer >= _config.downtime;\n  }\n\n  /**\n   * @param id Slot's ID for which the proof requirements should be checked. If the Slot's state is other than Filled, `false` is always returned.\n   * @return bool indicating if proof is required for current period\n   */\n  function isProofRequired(SlotId id) public view returns (bool) {\n    return _isProofRequired(id, _blockPeriod());\n  }\n\n  /**\n   * Proof Downtime specifies part of the Period when the proof is not required even\n   * if the proof should be required. This function returns true if the pointer is\n   * in downtime (hence no proof required now) and at the same time the proof\n   * will be required later on in the Period.\n   *\n   * @dev for more info about downtime see [timing of storage proofs](https://github.com/codex-storage/codex-research/blob/41c4b4409d2092d0a5475aca0f28995034e58d14/design/storage-proof-timing.md#pointer-downtime)\n   * @param id SlotId for which the proof requirements should be checked. If the Slot's state is other than Filled, `false` is always returned.\n   * @return bool\n   */\n  function willProofBeRequired(SlotId id) public view returns (bool) {\n    bool isRequired;\n    uint8 pointer;\n    (isRequired, pointer) = _getProofRequirement(id, _blockPeriod());\n    return isRequired && pointer < _config.downtime;\n  }\n\n  /**\n   * Function used for submitting and verification of the proofs.\n   *\n   * @dev Reverts when proof is invalid or had been already submitted.\n   * @dev Emits ProofSubmitted event.\n   * @param id Slot's ID for which the proof requirements should be checked\n   * @param proof Groth16 proof\n   * @param pubSignals Proofs public input\n   */\n  function _proofReceived(\n    SlotId id,\n    Groth16Proof calldata proof,\n    uint[] memory pubSignals\n  ) internal {\n    if (_received[id][_blockPeriod()]) revert Proofs_ProofAlreadySubmitted();\n    if (!_verifier.verify(proof, pubSignals)) revert Proofs_InvalidProof();\n\n    _received[id][_blockPeriod()] = true;\n    emit ProofSubmitted(id);\n  }\n\n  /**\n   * Function used to mark proof as missing.\n   *\n   * @param id Slot's ID for which the proof is missing\n   * @param missedPeriod Period for which the proof was missed\n   * @dev Reverts when:\n   *    - missedPeriod has not ended yet ended\n   *    - missing proof was time-barred\n   *    - proof was submitted\n   *    - proof was not required for missedPeriod period\n   *    - proof was already marked as missing\n   */\n  function _markProofAsMissing(SlotId id, Period missedPeriod) internal {\n    uint256 end = _periodEnd(missedPeriod);\n    if (end >= block.timestamp) revert Proofs_PeriodNotEnded();\n    if (block.timestamp >= end + _config.timeout)\n      revert Proofs_ValidationTimedOut();\n    if (_received[id][missedPeriod]) revert Proofs_ProofNotMissing();\n    if (!_isProofRequired(id, missedPeriod)) revert Proofs_ProofNotRequired();\n    if (_missing[id][missedPeriod]) revert Proofs_ProofAlreadyMarkedMissing();\n\n    _missing[id][missedPeriod] = true;\n    _missed[id] += 1;\n  }\n\n  event ProofSubmitted(SlotId id);\n}\n"
    },
    "contracts/Requests.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.28;\n\ntype RequestId is bytes32;\ntype SlotId is bytes32;\n\nstruct Request {\n  address client;\n  Ask ask;\n  Content content;\n  uint64 expiry; // amount of seconds since start of the request at which this request expires\n  bytes32 nonce; // random nonce to differentiate between similar requests\n}\n\nstruct Ask {\n  uint256 proofProbability; // how often storage proofs are required\n  uint256 pricePerBytePerSecond; // amount of tokens paid per second per byte to hosts\n  uint256 collateralPerByte; // amount of tokens per byte required to be deposited by the hosts in order to fill the slot\n  uint64 slots; // the number of requested slots\n  uint64 slotSize; // amount of storage per slot (in number of bytes)\n  uint64 duration; // how long content should be stored (in seconds)\n  uint64 maxSlotLoss; // Max slots that can be lost without data considered to be lost\n}\n\nstruct Content {\n  bytes cid; // content id, used to download the dataset\n  bytes32 merkleRoot; // merkle root of the dataset, used to verify storage proofs\n}\n\nenum RequestState {\n  New, // [default] waiting to fill slots\n  Started, // all slots filled, accepting regular proofs\n  Cancelled, // not enough slots filled before expiry\n  Finished, // successfully completed\n  Failed // too many nodes have failed to provide proofs, data lost\n}\n\nenum SlotState {\n  Free, // [default] not filled yet\n  Filled, // host has filled slot\n  Finished, // successfully completed\n  Failed, // the request has failed\n  Paid, // host has been paid\n  Cancelled, // when request was cancelled then slot is cancelled as well\n  Repair // when slot slot was forcible freed (host was kicked out from hosting the slot because of too many missed proofs) and needs to be repaired\n}\n\nlibrary AskHelpers {\n  function collateralPerSlot(Ask memory ask) internal pure returns (uint256) {\n    return ask.collateralPerByte * ask.slotSize;\n  }\n\n  function pricePerSlotPerSecond(\n    Ask memory ask\n  ) internal pure returns (uint256) {\n    return ask.pricePerBytePerSecond * ask.slotSize;\n  }\n}\n\nlibrary Requests {\n  using AskHelpers for Ask;\n\n  function id(Request memory request) internal pure returns (RequestId) {\n    return RequestId.wrap(keccak256(abi.encode(request)));\n  }\n\n  function slotId(\n    RequestId requestId,\n    uint64 slotIndex\n  ) internal pure returns (SlotId) {\n    return SlotId.wrap(keccak256(abi.encode(requestId, slotIndex)));\n  }\n\n  function toRequestIds(\n    bytes32[] memory ids\n  ) internal pure returns (RequestId[] memory result) {\n    // solhint-disable-next-line no-inline-assembly\n    assembly {\n      result := ids\n    }\n  }\n\n  function toSlotIds(\n    bytes32[] memory ids\n  ) internal pure returns (SlotId[] memory result) {\n    // solhint-disable-next-line no-inline-assembly\n    assembly {\n      result := ids\n    }\n  }\n\n  function maxPrice(Request memory request) internal pure returns (uint256) {\n    return\n      request.ask.slots *\n      request.ask.duration *\n      request.ask.pricePerSlotPerSecond();\n  }\n}\n"
    },
    "contracts/SlotReservations.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.28;\n\nimport \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\nimport \"./Requests.sol\";\nimport \"./Configuration.sol\";\n\nabstract contract SlotReservations {\n  using EnumerableSet for EnumerableSet.AddressSet;\n  error SlotReservations_ReservationNotAllowed();\n\n  mapping(SlotId => EnumerableSet.AddressSet) internal _reservations;\n  SlotReservationsConfig private _config;\n\n  constructor(SlotReservationsConfig memory config) {\n    _config = config;\n  }\n\n  function _slotIsFree(SlotId slotId) internal view virtual returns (bool);\n\n  function reserveSlot(RequestId requestId, uint64 slotIndex) public {\n    if (!canReserveSlot(requestId, slotIndex))\n      revert SlotReservations_ReservationNotAllowed();\n\n    SlotId slotId = Requests.slotId(requestId, slotIndex);\n    _reservations[slotId].add(msg.sender);\n\n    if (_reservations[slotId].length() == _config.maxReservations) {\n      emit SlotReservationsFull(requestId, slotIndex);\n    }\n  }\n\n  function canReserveSlot(\n    RequestId requestId,\n    uint64 slotIndex\n  ) public view returns (bool) {\n    address host = msg.sender;\n    SlotId slotId = Requests.slotId(requestId, slotIndex);\n    return\n      // TODO: add in check for address inside of expanding window\n      _slotIsFree(slotId) &&\n      (_reservations[slotId].length() < _config.maxReservations) &&\n      (!_reservations[slotId].contains(host));\n  }\n\n  event SlotReservationsFull(RequestId indexed requestId, uint64 slotIndex);\n}\n"
    },
    "contracts/StateRetrieval.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.28;\n\nimport \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\nimport \"./Requests.sol\";\n\ncontract StateRetrieval {\n  using EnumerableSet for EnumerableSet.Bytes32Set;\n  using Requests for bytes32[];\n\n  mapping(address => EnumerableSet.Bytes32Set) private _requestsPerClient;\n  mapping(address => EnumerableSet.Bytes32Set) private _slotsPerHost;\n\n  function myRequests() public view returns (RequestId[] memory) {\n    return _requestsPerClient[msg.sender].values().toRequestIds();\n  }\n\n  function mySlots() public view returns (SlotId[] memory) {\n    return _slotsPerHost[msg.sender].values().toSlotIds();\n  }\n\n  function _hasSlots(address host) internal view returns (bool) {\n    return _slotsPerHost[host].length() > 0;\n  }\n\n  function _addToMyRequests(address client, RequestId requestId) internal {\n    _requestsPerClient[client].add(RequestId.unwrap(requestId));\n  }\n\n  function _addToMySlots(address host, SlotId slotId) internal {\n    _slotsPerHost[host].add(SlotId.unwrap(slotId));\n  }\n\n  function _removeFromMyRequests(address client, RequestId requestId) internal {\n    _requestsPerClient[client].remove(RequestId.unwrap(requestId));\n  }\n\n  function _removeFromMySlots(address host, SlotId slotId) internal {\n    _slotsPerHost[host].remove(SlotId.unwrap(slotId));\n  }\n}\n"
    },
    "contracts/TestEndian.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.28;\n\nimport \"./Endian.sol\";\n\ncontract TestEndian is Endian {\n  function byteSwap(bytes32 input) public pure returns (bytes32) {\n    return _byteSwap(input);\n  }\n}\n"
    },
    "contracts/TestMarketplace.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.28;\n\nimport \"./Marketplace.sol\";\n\n// exposes internal functions of Marketplace for testing\ncontract TestMarketplace is Marketplace {\n  constructor(\n    MarketplaceConfig memory config,\n    IERC20 token,\n    IGroth16Verifier verifier\n  )\n    Marketplace(config, token, verifier) // solhint-disable-next-line no-empty-blocks\n  {}\n\n  function forciblyFreeSlot(SlotId slotId) public {\n    _forciblyFreeSlot(slotId);\n  }\n\n  function getSlotCollateral(SlotId slotId) public view returns (uint256) {\n    return _slots[slotId].currentCollateral;\n  }\n\n  function challengeToFieldElement(\n    bytes32 challenge\n  ) public pure returns (uint256) {\n    return _challengeToFieldElement(challenge);\n  }\n\n  function merkleRootToFieldElement(\n    bytes32 merkleRoot\n  ) public pure returns (uint256) {\n    return _merkleRootToFieldElement(merkleRoot);\n  }\n}\n"
    },
    "contracts/TestProofs.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.28;\n\nimport \"./Proofs.sol\";\n\n// exposes internal functions of Proofs for testing\ncontract TestProofs is Proofs {\n  mapping(SlotId => SlotState) private _states;\n  mapping(SlotId => uint256) private _probabilities;\n  // A _config object exist in Proofs but it is private.\n  // Better to duplicate this config in the test implementation\n  // rather than modifiying the existing implementation and change\n  // private to internal, which may cause problems in the Marketplace contract.\n  ProofConfig private _proofConfig;\n\n  constructor(\n    ProofConfig memory config,\n    IGroth16Verifier verifier\n  ) Proofs(config, verifier) {\n    _proofConfig = config;\n  }\n\n  function slotState(SlotId slotId) public view override returns (SlotState) {\n    return _states[slotId];\n  }\n\n  function startRequiringProofs(SlotId slot) public {\n    _startRequiringProofs(slot);\n  }\n\n  function markProofAsMissing(SlotId id, Period period) public {\n    _markProofAsMissing(id, period);\n  }\n\n  function proofReceived(\n    SlotId id,\n    Groth16Proof calldata proof,\n    uint[] memory pubSignals\n  ) public {\n    _proofReceived(id, proof, pubSignals);\n  }\n\n  function setSlotState(SlotId id, SlotState state) public {\n    _states[id] = state;\n  }\n\n  function slotProbability(\n    SlotId id\n  ) public view virtual override returns (uint256) {\n    return (_probabilities[id] * (256 - _proofConfig.downtime)) / 256;\n  }\n\n  function setSlotProbability(SlotId id, uint256 probability) public {\n    _probabilities[id] = probability;\n  }\n}\n"
    },
    "contracts/TestSlotReservations.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.28;\n\nimport \"./SlotReservations.sol\";\n\ncontract TestSlotReservations is SlotReservations {\n  using EnumerableSet for EnumerableSet.AddressSet;\n\n  mapping(SlotId => SlotState) private _states;\n\n  // solhint-disable-next-line no-empty-blocks\n  constructor(SlotReservationsConfig memory config) SlotReservations(config) {}\n\n  function contains(SlotId slotId, address host) public view returns (bool) {\n    return _reservations[slotId].contains(host);\n  }\n\n  function length(SlotId slotId) public view returns (uint256) {\n    return _reservations[slotId].length();\n  }\n\n  function _slotIsFree(SlotId slotId) internal view override returns (bool) {\n    return _states[slotId] == SlotState.Free;\n  }\n\n  function setSlotState(SlotId id, SlotState state) public {\n    _states[id] = state;\n  }\n}\n"
    },
    "contracts/TestToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.28;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\ncontract TestToken is ERC20 {\n  // solhint-disable-next-line no-empty-blocks\n  constructor() ERC20(\"TestToken\", \"TST\") {}\n\n  function mint(address holder, uint256 amount) public {\n    _mint(holder, amount);\n  }\n}\n"
    },
    "contracts/TestVerifier.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.28;\n\nimport \"./Groth16.sol\";\n\ncontract TestVerifier is IGroth16Verifier {\n  function verify(\n    Groth16Proof calldata proof,\n    uint[] calldata\n  ) external pure returns (bool) {\n    // accepts any proof, except the proof with all zero values\n    return\n      !(proof.a.x == 0 &&\n        proof.a.y == 0 &&\n        proof.b.x.real == 0 &&\n        proof.b.x.imag == 0 &&\n        proof.b.y.real == 0 &&\n        proof.b.y.imag == 0 &&\n        proof.c.x == 0 &&\n        proof.c.y == 0);\n  }\n}\n"
    }
  },
  "settings": {
    "evmVersion": "paris",
    "optimizer": {
      "enabled": true,
      "runs": 1000
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}